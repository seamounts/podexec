// // Copyright 2015 The Gorilla WebSocket Authors. All rights reserved.
// // Use of this source code is governed by a BSD-style
// // license that can be found in the LICENSE file.

// // +build ignore

// package main

// import (
// 	"fmt"
// 	"io"
// 	"net/url"
// 	"os"
// 	"time"

// 	dockerterm "github.com/docker/docker/pkg/term"
// 	corev1 "k8s.io/api/core/v1"
// 	"k8s.io/cli-runtime/pkg/genericclioptions"
// 	"k8s.io/client-go/kubernetes"
// 	coreclient "k8s.io/client-go/kubernetes/typed/core/v1"
// 	restclient "k8s.io/client-go/rest"
// 	"k8s.io/client-go/tools/clientcmd"
// 	"k8s.io/client-go/tools/remotecommand"
// 	"k8s.io/kubectl/pkg/polymorphichelpers"
// 	"k8s.io/kubectl/pkg/util/interrupt"
// 	"k8s.io/kubectl/pkg/util/term"
// )

// func main() {
// 	streams := genericclioptions.IOStreams{In: os.Stdin, Out: os.Stdout, ErrOut: os.Stdout}

// 	options := &ExecOptions{

// 		StreamOptions: StreamOptions{
// 			Stdin:     true,
// 			TTY:       true,
// 			IOStreams: streams,
// 		},

// 		Executor: &DefaultRemoteExecutor{},
// 	}
// 	if err := options.Complete(); err != nil {
// 		panic(err)
// 	}

// 	// if err := options.Run(); err != nil {
// 	// 	panic(err)
// 	// }

// 	if err := options.RunT3(); err != nil {
// 		panic(err)
// 	}
// }

// // RemoteExecutor defines the interface accepted by the Exec command - provided for test stubbing
// type RemoteExecutor interface {
// 	Execute(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error
// }

// // DefaultRemoteExecutor is the standard implementation of remote command execution
// type DefaultRemoteExecutor struct{}

// func (*DefaultRemoteExecutor) Execute(method string, url *url.URL, config *restclient.Config, stdin io.Reader, stdout, stderr io.Writer, tty bool, terminalSizeQueue remotecommand.TerminalSizeQueue) error {
// 	exec, err := remotecommand.NewSPDYExecutor(config, method, url)
// 	if err != nil {
// 		return err
// 	}

// 	// fmt.Println("------Execute", stdin, stdout, tty)
// 	return exec.Stream(remotecommand.StreamOptions{
// 		Stdin:             stdin,
// 		Stdout:            stdout,
// 		Stderr:            stderr,
// 		Tty:               tty,
// 		TerminalSizeQueue: terminalSizeQueue,
// 	})
// }

// type StreamOptions struct {
// 	Namespace     string
// 	PodName       string
// 	ContainerName string
// 	Stdin         bool
// 	TTY           bool
// 	// minimize unnecessary output
// 	Quiet bool
// 	// InterruptParent, if set, is used to handle interrupts while attached
// 	InterruptParent *interrupt.Handler

// 	genericclioptions.IOStreams

// 	// for testing
// 	overrideStreams func() (io.ReadCloser, io.Writer, io.Writer)
// 	isTerminalIn    func(t term.TTY) bool
// }

// // ExecOptions declare the arguments accepted by the Exec command
// type ExecOptions struct {
// 	StreamOptions

// 	ResourceName string
// 	Command      []string

// 	ParentCommandName       string
// 	EnableSuggestedCmdUsage bool

// 	// Builder          func() *resource.Builder
// 	ExecutablePodFn  polymorphichelpers.AttachablePodForObjectFunc
// 	restClientGetter genericclioptions.RESTClientGetter

// 	Pod           *corev1.Pod
// 	Executor      RemoteExecutor
// 	PodClient     coreclient.PodsGetter
// 	GetPodTimeout time.Duration
// 	Config        *restclient.Config
// }

// // Complete verifies command line arguments and loads data from the command environment
// func (p *ExecOptions) Complete() error {
// 	p.ResourceName = ""
// 	p.PodName = "kce-hydra"
// 	p.ContainerName = "hydra"
// 	p.Command = []string{"sh"}

// 	p.GetPodTimeout = 3 * time.Second

// 	var err error

// 	p.Namespace = "default"

// 	p.ExecutablePodFn = polymorphichelpers.AttachablePodForObjectFn

// 	p.Config, err = getRestConfig()
// 	if err != nil {
// 		return err
// 	}

// 	clientset, err := kubernetes.NewForConfig(p.Config)
// 	if err != nil {
// 		return err
// 	}
// 	p.PodClient = clientset.CoreV1()

// 	return nil
// }

// func getRestConfig() (*restclient.Config, error) {
// 	homeDir, err := os.UserHomeDir()
// 	if err != nil {
// 		return nil, err
// 	}

// 	kubeconfigPath := fmt.Sprintf("%s/.kube/config", homeDir)

// 	fmt.Println(kubeconfigPath)

// 	config, err := clientcmd.BuildConfigFromFlags("", kubeconfigPath)

// 	return config, err
// }

// // Validate checks that the provided exec options are specified.
// func (p *ExecOptions) Validate() error {
// 	if len(p.PodName) == 0 && len(p.ResourceName) == 0 {
// 		return fmt.Errorf("pod or type/name must be specified")
// 	}
// 	if len(p.Command) == 0 {
// 		return fmt.Errorf("you must specify at least one command for the container")
// 	}
// 	if p.Out == nil || p.ErrOut == nil {
// 		return fmt.Errorf("both output and error output must be provided")
// 	}
// 	return nil
// }

// func (o *StreamOptions) SetupTTY() term.TTY {
// 	t := term.TTY{
// 		Parent: o.InterruptParent,
// 		Out:    o.Out,
// 	}

// 	if !o.Stdin {
// 		// need to nil out o.In to make sure we don't create a stream for stdin
// 		o.In = nil
// 		o.TTY = false
// 		return t
// 	}

// 	t.In = o.In
// 	if !o.TTY {
// 		return t
// 	}

// 	if o.isTerminalIn == nil {
// 		o.isTerminalIn = func(tty term.TTY) bool {
// 			return tty.IsTerminalIn()
// 		}
// 	}
// 	if !o.isTerminalIn(t) {
// 		o.TTY = false

// 		if o.ErrOut != nil {
// 			fmt.Fprintln(o.ErrOut, "Unable to use a TTY - input is not a terminal or the right kind of file")
// 		}

// 		return t
// 	}

// 	// if we get to here, the user wants to attach stdin, wants a TTY, and o.In is a terminal, so we
// 	// can safely set t.Raw to true
// 	t.Raw = true

// 	if o.overrideStreams == nil {
// 		// use dockerterm.StdStreams() to get the right I/O handles on Windows
// 		o.overrideStreams = dockerterm.StdStreams
// 	}
// 	stdin, stdout, _ := o.overrideStreams()
// 	o.In = stdin
// 	t.In = stdin
// 	if o.Out != nil {
// 		o.Out = stdout
// 		t.Out = stdout
// 	}

// 	return t
// }

// // Run executes a validated remote execution against a pod.
// func (p *ExecOptions) Run() error {
// 	// ensure we can recover the terminal while attached
// 	t := p.SetupTTY()

// 	var sizeQueue remotecommand.TerminalSizeQueue
// 	if t.Raw {
// 		// this call spawns a goroutine to monitor/update the terminal size
// 		sizeQueue = t.MonitorSize(t.GetSize())

// 		// unset p.Err if it was previously set because both stdout and stderr go over p.Out when tty is
// 		// true
// 		p.ErrOut = nil
// 	}

// 	fn := func() error {
// 		kubeClient, err := kubernetes.NewForConfig(p.Config)
// 		if err != nil {
// 			return err
// 		}
// 		restClient := kubeClient.RESTClient()

// 		// TODO: consider abstracting into a client invocation or client helper
// 		req := restClient.Post().
// 			Prefix(fmt.Sprintf("/api/v1")).
// 			Resource("pods").
// 			Name(p.PodName).
// 			Namespace(p.Namespace).
// 			SubResource("exec").
// 			Param("container", p.ContainerName).
// 			Param("stdin", "true").
// 			Param("stdout", "true").
// 			Param("stderr", "true").
// 			Param("tty", "true").
// 			Param("command", "sh")

// 		return p.Executor.Execute("POST", req.URL(), p.Config, p.In, p.Out, p.ErrOut, t.Raw, sizeQueue)
// 	}

// 	if err := t.Safe(fn); err != nil {
// 		return err
// 	}

// 	return nil
// }

// func (p *ExecOptions) RunT() error {
// 	t := p.SetupTTY()

// 	var sizeQueue remotecommand.TerminalSizeQueue
// 	if t.Raw {
// 		// this call spawns a goroutine to monitor/update the terminal size
// 		sizeQueue = t.MonitorSize(t.GetSize())

// 		// unset p.Err if it was previously set because both stdout and stderr go over p.Out when tty is
// 		// true
// 		p.ErrOut = nil
// 	}

// 	fn := func() error {
// 		u, err := url.Parse("https://120.92.15.67:6443")
// 		if err != nil {
// 			return err
// 		}

// 		vars := url.Values{}
// 		vars.Add("container", p.ContainerName)
// 		vars.Add("command", "sh")
// 		vars.Add("stdout", "true")
// 		vars.Add("stdin", "true")
// 		vars.Add("stderr", "true")
// 		vars.Add("tty", "true")

// 		u.Path = fmt.Sprintf("/api/v1/namespaces/%s/pods/%s/exec", p.Namespace, p.PodName)
// 		u.RawQuery = vars.Encode()

// 		fmt.Println(u)

// 		return p.Executor.Execute("POST", u, p.Config, p.In, p.Out, p.ErrOut, t.Raw, sizeQueue)
// 	}

// 	if err := t.Safe(fn); err != nil {
// 		return err
// 	}

// 	return nil
// }

// func (p *ExecOptions) RunT2() error {
// 	t := p.SetupTTY()

// 	var sizeQueue remotecommand.TerminalSizeQueue
// 	if t.Raw {
// 		// this call spawns a goroutine to monitor/update the terminal size
// 		sizeQueue = t.MonitorSize(t.GetSize())

// 		// unset p.Err if it was previously set because both stdout and stderr go over p.Out when tty is
// 		// true
// 		p.ErrOut = nil
// 	}

// 	fn := func() error {
// 		u, err := url.Parse("https://kce.registry.cn-shanghai-2.sdns.ksyun.com:443")
// 		if err != nil {
// 			return err
// 		}

// 		u.Path = fmt.Sprintf("/cluster-management/8b7face4-32f3-427e-b4c4-fa09d1f93030/shell")

// 		fmt.Println(u)

// 		return p.Executor.Execute("POST", u, p.Config, p.In, p.Out, p.ErrOut, t.Raw, sizeQueue)
// 	}

// 	if err := t.Safe(fn); err != nil {
// 		return err
// 	}

// 	return nil
// }

// const (
// 	AGENT_NAMESPACE = "kube-system"
// 	AGENT_LABEL     = "app=ksyun-cluster-agent"
// 	AGENT_CONTAINER = "cluster-register"
// 	AGENT_CMD       = "kubectl-shell.sh"
// )

// func (p *ExecOptions) RunT3() error {
// 	t := p.SetupTTY()

// 	var sizeQueue remotecommand.TerminalSizeQueue
// 	if t.Raw {
// 		// this call spawns a goroutine to monitor/update the terminal size
// 		sizeQueue = t.MonitorSize(t.GetSize())

// 		// unset p.Err if it was previously set because both stdout and stderr go over p.Out when tty is
// 		// true
// 		p.ErrOut = nil
// 	}

// 	fn := func() error {
// 		u, err := url.Parse("https://kce.registry.cn-shanghai-2.sdns.ksyun.com:443")
// 		if err != nil {
// 			return err
// 		}

// 		vars := url.Values{}
// 		vars.Add("container", AGENT_CONTAINER)
// 		vars.Add("command", AGENT_CMD)
// 		vars.Add("stdout", "true")
// 		vars.Add("stdin", "true")
// 		vars.Add("stderr", "true")
// 		vars.Add("tty", "true")

// 		u.Path = fmt.Sprintf("/k8s/clusters/8b7face4-32f3-427e-b4c4-fa09d1f93030/api/v1/namespaces/%s/pods/%s/exec",
// 			AGENT_NAMESPACE, "ksyun-cluster-agent-7649dd6d9d-6lsgp")

// 		u.RawQuery = vars.Encode()

// 		fmt.Println(u)

// 		return p.Executor.Execute("POST", u, p.Config, p.In, p.Out, p.ErrOut, t.Raw, sizeQueue)
// 	}

// 	if err := t.Safe(fn); err != nil {
// 		return err
// 	}

// 	return nil
// }
